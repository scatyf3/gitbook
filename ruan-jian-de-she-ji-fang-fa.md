# 软件的设计方法

## 软件的设计方法

​![image](<.gitbook/assets/image 20231224212523 j5xxgdq.png>)​

## 面向对象的软件设计

### 设计过程

识别设计类

​![image](<.gitbook/assets/image 20231224220630 i77hjp7.png>)​

明确设计类职责和协作

​![image](<.gitbook/assets/image 20231224220644 54womud.png>)​

细化设计类内部细节

​![image](<.gitbook/assets/image 20231224220701 7z0oq7g.png>)​

### 设计描述-UML

很重要，大概率要考图片的绘制

统一建模语言,是由一整套图表组成的,为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言

​![image](<.gitbook/assets/image 20231224220747 u5s3nxq.png>)​

​![image](<.gitbook/assets/image 20231224220814 8zcuufh.png>)​

​![image](<.gitbook/assets/image 20231224220822 5en3ayj.png>)​

## 设计原则

• 单一职责原则(Single Responsibility Principle):每个类、接口、方法都应该只具有单一的职责，应该只会因为一个原因发生变化\
​![image](<.gitbook/assets/image 20231224222455 bbjsmwo.png>)​

• 开闭原则(Open Closed Principle): 模块应该对扩展开放、对修改封闭\
​![image](<.gitbook/assets/image 20231224222511 7nk1zif.png>)​

• 里氏替换原则(Liskov Substitution Principle):子类对象可以出现在任何父类对象出现的地方\
​![image](<.gitbook/assets/image 20231224222638 tkw4g8r.png>)​

迪米特法则:强调不要和“陌生人”说话,只与直接“朋友”交谈\
​![image](<.gitbook/assets/image 20231224222707 cjqb8ao.png>)​

• 接口隔离原则(Interface Segregation Principle):**多个服务于特定请求方的接口好过一个通用接口,不要强迫一个类依赖它不会使用的接口**\
​![image](<.gitbook/assets/image 20231224222834 xcrzyn8.png>)​

• 依赖转置原则(Dependence Inversion Principle):强调应该尽量依赖于抽象(例如抽象类、接口)而非具体(例如具体的实现类)\
​![image](<.gitbook/assets/image 20231224222917 uzmf3jz.png>)​

### 契约式设计

•基本思想：建立不同类（或者模块）之间的契约关系，以一种可检查的方式明确定义接口的实现方和调用方各自应当承担的“权利”和“义务”。即将接口的实现方和调用方之间的关系比喻成商业活动中供应方与需求方之间的关系

•契约应当明确定义并且可以进行验证->可以设置断言

设计：前置条件，后置条件，不变式

​![image](<.gitbook/assets/image 20231225005224 x05a36z.png>)​

基本原则【这是什么】

区分命令和查询\
命令能够改变对象的状态（例如属性取值），而查询则只是返回结果而不改变对象状态，两类方法需要分开\
区分基本查询和派生查询\
基本查询是指直接对类属性和对象状态进行查询，而派生查询则是在其他查询基础上派生定义出来的\
针对每个派生查询定义一个使用基本查询表示的后置条件\
为每个命令定义一个后置条件，规定每个基本查询的值\
为每个查询和命令定义合适的前置条件\
通过不变式定义对象的恒定特性

现实生活：实现运行时检查\
Java程序可以使用Contracts for Java、iContract2、Contract4J等扩展\
也可以利用**断言机制**简单地实现类似契约的机制，例如在每个方法开始和结束的地方利用断言分别对前置条件和后置条件进行检查

### 设计模式

【这个似乎 in real life 也很实用】

•设计模式是指针对一类相似设计问题的通用和参考性的设计方案，一般都经过大量的实践验证，能够较好地实现相关的设计目标

存在23中面向对象的设计模式及其基本要素\
​![image](<.gitbook/assets/image 20231225005501 euk8gq5.png>)​

### 单例模式

一个类只允许有一个对象实例\
例如操作系统中的任务管理器和回收站、网站的计数器、金融交易的引擎、应用程序的日志引擎等

**参考设计方案**\
将构造方法设为私有\
内部包含一个类型为自身的静态成员对象（instance）\
通过一个静态方法（getInstance）用于获取这个成员对象的引用

### 适配器模式

​![image](<.gitbook/assets/image 20231225010028 7nxog0k.png>)​

•一个类所需要的接口与另一个类所提供的接口不匹配，但功能相同或相近，此时可以通过适配器在二者之间进行转换和适配

​![image](<.gitbook/assets/image 20231225005720 g4mw79l.png>)​

额外引入的适配器类（Adapter）一方面继承了Adaptee从而具备了该类所实现的能力，另一方面则实现了Target接口\
客户端类创建Adapter类的对象实例后可以将其作为接口Target的对象实例进行使用

### 组合模式

需要处理的对象构成了一种表示整体部分层次的树状结构，例如文件系统中嵌套的目录结构、画图工具中嵌套的复合图形\
客户端开发人员希望以一种统一的方式处理对象以及对象的组合，从而避免在代码中针对不同类型对象采取不同的处理策略（例如，对于原子对象直接调用操作，而对于复合结构则需要遍历其所包含的对象或下一级复合结构进行处理

​![image](<.gitbook/assets/image 20231225010107 s8gjegy.png>)​

### 策略模式

一些软件功能的实现涉及算法策略选择的问题（例如图形布局），而其中的算法策略存在很多种不同的选择\
希望功能实现与算法策略之间实现松耦合的依赖，从而在更换算法或增加新算法时对功能实现的影响能够最小化

​![image](<.gitbook/assets/image 20231225010146 wzzff6b.png>)​

### 观察者模式

在**包含用户界面的应用程序**中，经常存在同样的数据对象通过多种不同的形式进行可视化展示的情况，例如关于道路交通的实时监控数据可以通过地图、表格以及各种统计图表等不同的形式来展现\
数据的状态发生变化后各个展现视图都需要随之更新\
各个视图都有可能发生变化，未来还有可能增加新的展现方式\
按照单一职责原则以及开闭原则，我们希望数据管理与数据展现相分离，同时新增展现视图无需修改已有的代码

​​

‍![](<.gitbook/assets/image (7).png>)

## 面向切面的编程

oop的问题：\
•代码交织（code tangling）：与多个关注点相关的实现代码混杂在一个模块中\
• 代码散布（code scattering）：与同一个关注点相关的实现代码分散在多个模块中

​![image](<.gitbook/assets/image 20231224223201 065xa8w.png>)​

​![image](<.gitbook/assets/image 20231224223212 94ewaef.png>)​

### 基本概念

•切面（Aspect）：实现关注点的模块化单元

•通知（Advice）：由切面所封装的、将插入到基本程序中指定地方执行的功能代码

•连接点（Join point）：基本程序结构或者执行流上的一种可以明确定义的位置

•切点指示器（Pointcut Designator）：为切面的定义提供了一种批量描述一系列连接点上的插入位置的机制

•编织（Weave）：将基本程序与切面集成到一起获得完整程序的过程

不理解，让ai生成了一个例子

> 当你编写一个Web应用程序时，你可能会遇到需要记录日志的需求。你可以使用面向切面编程来实现日志记录，以便将日志记录的逻辑与业务逻辑分离。
>
> 1. 切面（Aspect）：在这个例子中，切面是日志记录功能的模块化单元。它定义了在哪些连接点上执行日志记录通知。例如，你可以定义一个名为 "LoggingAspect" 的切面来处理日志记录。
> 2. 通知（Advice）：通知是切面封装的功能代码，用于执行具体的操作。在这个例子中，你可以定义一个后置通知（After advice），在每个方法执行后记录日志。这个后置通知会在连接点之后执行，将方法的执行信息记录到日志文件中。
> 3. 连接点（Join point）：连接点是程序执行的明确定义的位置。在这个例子中，连接点可以是每个方法的调用或执行。切面通过定义后置通知在这些连接点上执行来实现日志记录。例如，当调用某个方法时，后置通知会在方法执行后被插入，并记录相关日志信息

真的不会了，mark几篇搜索引擎指数很高的文章，然后明天再说吧

https://www.liaoxuefeng.com/wiki/1252599548343744/1266265125480448

https://www.zhihu.com/question/24863332

https://pdai.tech/md/spring/spring-x-framework-aop.html

### 实现方式

•针对主流语言的AOP语言扩展及编程框架：AspectJ、AspectWerkz、JBoss AOP、Spring AOP、AspectSharp、AspectC++等

•**Spring AOP**

‍
